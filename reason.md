#使用文件系统的原因

##如果没有文件系统
	如果我们不在硬盘本身建立文件系统，我们直接面对硬盘的扇区。
###如何写文件
	先看看对于操作普通文件来说，意味着什么。
　　我们要拿着一个小本本，上面记着，文件名，文件所在扇区以及文件大小。每次要读写文件，我们要人工查询这个账本，知道我们要的文件在哪里。如果文件A所在的扇区M已经写满了，随后的一个扇区M+1被文件B占用了，我们还想接着写文件A，怎么办呢？只能从其他地方找一个空闲扇区N，然后在账本上把N记录到文件A占用的扇区项中。我们如何知道硬盘上还有哪些空间可以用呢？难道每次都从前往后把扇区使用情况计算一遍吗吗？可能还需要另起一个账本记录扇区使用情况，删除文件，我们把对应的扇区标记为空闲，如果创建文件，把对应的扇区标记为不能使用。
对于操作系统而言呢？我觉得，没有文件系统就不会有操作系统，这样的操作系统充其量就是一个硬盘驱动。为什么？可以设想一下创建文件的过程:
    用户告诉这样的操作系统，说要创建一个文件A
    计算机输出，请你自己记录好文件名，并告诉我要在哪个扇区创建。并且记录好这个文件你占用了哪些扇区

###提炼上述过程中我们需要知道的信息
	将变化的放在一起，将不变的放在一起。统一才有美感。
**dir_entry**

对于文件使用情况的账本而言，看起来要表述一个文件在硬盘上的信息，我们需要知道它占用了哪些扇区，它的名字，文件大小这样的信息。那么这些信息应该放在哪里呢？当然可以随机存放，但是存放完了，计算机如何在下次使用的时候找到这个文件呢？还是需要一份记录来索引这些信息，还不如把这些文件信息按照统一格式存放在一起，这就是目录结构(dir_entry)的由来。按照树状目录能得到任何文件信息。
	
**sector_map**

对于硬盘使用情况的账本而言，要记录好哪些扇区空闲，哪些已经被使用了。这就是sector_map的由来。
	
**super_block**

那么这些账本本身是存在于硬盘的某些地方，还需要一个总账本来记录这些管理块的信息，这个总账本就是super_block。
	
**inode**
那么inode的由来呢？为什么文件名和inode分开存放呢？
试想一下，如果文件名和文件的属性信息一起存放的话，一个文件目录项会占用很大的空间，一个扇区也许只能存几个文件的信息，而系统在查找文件的时候，可能要读很多次扇区才能找到需要的文件，这样大大影响系统的效率。毕竟我们在找文件的时候，不需要文件的信息，不需要知道文件大小、所在扇区等等信息全部与查找无关，为什么要这些信息来影响我们的速度呢？我们只要文件名来判断这是不是我们要找的文件。所以将文件的其余信息剥离出来概括为inode结构体。
	
**inode_array**

inode单独列出来了，存放在哪里呢？如何通过dir_entry找到inode呢？当然可以存放于任何扇区上，只不过dir_entry可能要加上inode所在扇区和在扇区中的偏移两个字段了，随之而来问题就是存放inode的扇区只能用来存放其他inode而不能用来存放文件数据了，因为我们给文件分配空间是按照扇区为单位的，难道一个扇区分给文件时候，还要记上一笔在偏移offset处是inode占用的，读写的时候请跳过，这样的逻辑恐怕没人会去用代码实现它吧。另外，由于“存放inode的扇区只能用来存放其他inode而不能用来存放文件数据”这样的原因，设计者就折中了一下，把indoe占用的扇区都提到一个单独空间，以后所有的inode都放到这个空间里，这个空间就是inode_array。
　　当然也会出现问题，可能inode_array满了，而硬盘空间还要很大剩余；或者硬盘空间嘛呢，inode_array还有很多剩余。这是很极端的情况，总要有不尽人意的地方，那就把这个不足最小化吧。
　　在存放inode的时候，怎么知道inode_array中哪个下标可以用呢？这就是又需要一份记录，来记录inode_array中哪些是空闲的，哪些是已经使用，这个记录就是inode_map。而inode在inode_array中的下标就是inode_num。dir_entry中记录了这个inode_num就可以在inode_array中找到对应的文件信息了。
